#!/usr/bin/env python
# -*- coding:utf-8 -*-
# @FileName :2.零钱兑换2.py
# @Time     :2022/3/24 上午11:47
# @Author   :Chang Qing
 
"""
leetcode 518  完全背包求组合数

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。

示例 1:

输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1

示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。

示例 3: 输入: amount = 10, coins = [10] 输出: 1

注意，你可以假设：

0 <= amount (总金额) <= 5000
1 <= coin (硬币面额) <= 5000
硬币种类不超过 500 种
结果符合 32 位符号整数

思路：
这是一道典型的背包问题，一看到钱币数量不限，就知道这是一个完全背包。
对完全背包还不了解的同学，可以看这篇：动态规划：关于完全背包，你该了解这些！
但本题和纯完全背包不一样，纯完全背包是能否凑成总金额，而本题是要求凑成总金额的个数！
注意题目描述中是凑成总金额的硬币组合数，为什么强调是组合数呢？
例如示例一：
5 = 2 + 2 + 1
5 = 2 + 1 + 2
这是一种组合，都是 2 2 1。
如果问的是排列数，那么上面就是两种排列了。

回归本题，动规五步曲来分析如下：

1.确定dp数组以及下标的含义
dp[j]：凑成总金额j的货币组合数为dp[j]

2.确定递推公式
dp[j] （考虑coins[i]的组合总和） 就是所有的dp[j - coins[i]]（不考虑coins[i]）相加。

所以递推公式：dp[j] += dp[j - coins[i]];

这个递推公式大家应该不陌生了，我在讲解01背包题目的时候在这篇动态规划：目标和！中就讲解了，求装满背包有几种方法，一般公式都是：dp[j] += dp[j - nums[i]];

3.dp数组如何初始化
首先dp[0]一定要为1，dp[0] = 1是 递归公式的基础。

从dp[i]的含义上来讲就是，凑成总金额0的货币组合数为1。

下标非0的dp[j]初始化为0，这样累计加dp[j - coins[i]]的时候才不会影响真正的dp[j]

4.确定遍历顺序
本题中我们是外层for循环遍历物品（钱币），内层for遍历背包（金钱总额），还是外层for遍历背包（金钱总额），内层for循环遍历物品（钱币）呢？
我在动态规划：关于完全背包，你该了解这些！中讲解了完全背包的两个for循环的先后顺序都是可以的。

但本题就不行了！

因为纯完全背包求得是能否凑成总和，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！

而本题要求凑成总和的组合数，元素之间要求没有顺序。
所以纯完全背包是能凑成总和就行，不用管怎么凑的。
本题是求凑出来的方案个数，且每个方案个数是为组合数。
那么本题，两个for循环的先后顺序可就有说法了。（先遍历物品，后遍历背包求的是组合数， 先遍历背包，再遍历物品，求的是排列数）

5.举例推导dp数组

总结：
如果求组合数就是外层for循环遍历物品，内层for遍历背包。
如果求排列数就是外层for遍历背包，内层for循环遍历物品。

reference: 强烈建议
htreferencetps://github.com/youngyangyang04/leetcode-master/blob/master/problems/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.md
"""

class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0]*(amount + 1)
        dp[0] = 1
        # 遍历物品
        for i in range(len(coins)):
            # 遍历背包
            for j in range(coins[i], amount + 1):
                dp[j] += dp[j - coins[i]]
        return dp[amount]